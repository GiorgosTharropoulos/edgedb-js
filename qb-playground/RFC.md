# Query builder

## Type system

EdgeDB's type system can be represented as either interfaces or branded types, which both support an analog of multiple interitance.

"Multiple inheritance" is used to represent implicit casting/compatibilty. e.g. `Int64` extends `Float64` and `BigInt`.

- interface AnyType<TSType>
  - Bool
  - Bytes
  - UUID
  - String
  - Datetime
  - Duration
  - Local{Date|Time|DateTime}
  - Decimal
  - BigInt
  - Float64
  - Float32
  - Int64
  - Int32
  - Int16
  - Enum
    - auto-generated subclasses
  - Array<ElementType>
  - Tuple<Elements>
  - Link<Target extends ObjectType, Source extends ObjectType>
  - ObjectType<Properties, Links>
    - auto-generated subclasses
  - Set<ElementType extends Type, Cardinality extends "set" | "singleton" | "empty" | "atmostone" | "atleastone" = "set">

## Class structure

All syntactic structures are subclasses of `Expression` augmented with a mixin according to its return type. This is necessary to enable things like creating path expressions from subqueries, etc.

```ts
Expression<Output extends Set<any, any>, TSType> {}
```

Proposed subclass tree

- Expression<Output extends Set<unknown>, TSType>
  - Literal
    - subclasses
  - ObjectSetReference<ObjectType, Shape>
    - autogenerated for each object type
    - available as `e.default.Hero`, `e.default.Movie`, etc.
    - paths represented as linked links with `_parent` property
  - PropertySetReference
    - paths represented as linked links with `_parent` property
  - Statement
    - Select
    - Insert
    - Update
    - Delete
    - With
    - ForIn
  - Operator<...Args>
    - subclasses for each operator
    - plus an overloaded factory function
  - FunctionCall<...Args>
    - subclasses for each built-in function
    - plus an overloaded factory function

## Literals

```ts
e.str("234"); // naked string literals supported where possible
e.int64(123);
e.float64(1234.1234);
e.bool(true);
e.bigint(12345);

e.decimal("1234.1234n");
e.datetime(`2021-06-04T02:26:18.617Z`);
e.localDatetime(`2021-06-04T02:26:18.617193`);
e.duration("45.6 seconds");
e.uuid("599236a4-2a5e-4249-91b6-ec435d3afe20");
e.json(JSON.stringify({asdf: 1234}));

e.enums.CustomEnum.green;
```

## Sets and overloading

```ts
e.set(e.str("asdf"), e.str("qwer"));
// => SetLiteral<Set<String>, string[]>
```

Overload with support for naked strings

```ts
e.set("asdf", "asdf");
// => SetLiteral<Set<String>, string[]>
```

Disallow incompatible types.

```ts
e.set(e.str("asdf"), e.int32(12)); // TypeError
```

Use overloading to represent implicit casting behavior

```ts
// allow castable heterogeneous types
e.set(e.int16(1234), e.int64(1234));
// => Literal<Set<Int64>, number[]>
e.set(e.int64(1234), e.float(12.34));
// => Literal<Set<Float64>, number[]>
```

Correctly typing heterogeneous literal sets can be accomplished by properly constructing the scalar graph and relying on TypeScript's overloading order. Proof of concept:

```ts
type AnyType = {__type: true};
type Str = AnyType & {__str: true};
type Bool = AnyType & {__bool: true};
type Decimal = AnyType & {__decimal: true};
type BigInt = Decimal & {__bigint: true};
type Float64 = AnyType & {__float64: true};
type Float32 = Float64 & {__float32: true};
type Int64 = Float64 & BigInt & {__int64: true};
type Int32 = Int64 & {__int32: true};
type Int16 = Int32 & {__int16: true};

function infer<T extends AnyType>(...args: T[]): T[];
function infer(...args: Float64[]): Float64[];
function infer(...args: any) {
  return args as any;
}

const VAL = "whatever" as any;

infer(VAL as Int32, VAL as Int64);
// => Int64[]
infer(VAL as Int64, VAL as Float32);
// => Float64[] <- shared parent (caught by second overload)
infer(VAL as Int64, VAL as Decimal);
// => Decimal[]
```

## Arrays

```ts
e.array([e.str(5)]);
```

As with sets, heterogeneous compatible types are valid

```ts
e.array([e.int16(5), e.int64(51234)]);
```

## Tuples

Named

```ts
e.tuple({
  name: e.str("Peter Parker"),
  age: e.int64(18),
});
```

Unnamed

```ts
e.tuple([e.str("Peter Parker"), e.int64(100)]);
```

## Set references

### Object set references

Module-scoped set references. Instance of `ObjectSetReference`.

```ts
e.default.Hero;
e.default.Villain;
e.default.Movie;
e.myModule.MyType;
```

### Deconstruction for convenience

```ts
const {Hero, Villain, Movie, Person} = e.default;
```

### Property set references

Returns `PropertySetReference`.

```ts
Hero.name;
Movie.title;
```

### Traverse links

Returns another `ObjectSetReference`.

```ts
Hero.villains;
Movie.characters;
```

### Type filters

```ts
e.is(Hero, Movie.characters);
```

### Backward links

```ts
Hero.nemesis_Villain;
Hero.characters_Movie;
```

## SELECT

### Simple select

Shape defaults to `{ id: true }`;

```ts
e.select(Hero);
```

### Object-defined shape

```ts
e.select(Hero, {
  id: true,
  name: true,
  villains: {
    id: true,
    name: true,
  },
});
```

### Basic filtering

```ts
e.select(Hero, {
  id: true,
  name: true,
})
  .filter(e.ilike(Hero.name, "%Man"))
  .filter(e.ilike(Hero.secret_identity, "Peter%"));
```

> Filters are checked to determine whether the result set should be a singleton or not.

### Nested filtering

```ts
e.select(Hero, {
  id: true,
  name: true,
  villains: e
    .select(Villain, {
      id: true,
      name: true,
    })
    .filter(e.eq(e.len(Hero.name), e.len(Villain.name))),
}).filter(e.eq(Hero.name, e.str("Iron Man")));
```

### Computables

```ts
const Person = e.default.Person;

e.select(Person, {
  id: true,
  name: true,
  uppercase_name: e.str_upper(Person.name)
  is_hero: e.is(Person, e.default.Hero),
});
```

### Arguments

```ts
const fetchPerson = e.params({name: e.Array(e.Str)}, (args) =>
  e
    .select(Person, {
      id: true,
    })
    .filter(e.in(Person.name, e.array_unpack(args.name)))
);
```

Alternative (typechecking args not possible):

```ts
e.select(Person, {
  id: true,
}).filter(e.in(Person.name, e.array_unpack(e.args("name", e.ARRAY(e.str)))));
```

### Polymorphism

Option 1. Precludes the ability to add additional parameters/options to `e.select`, as it would be variadic.

```ts
e.select(
  Person,
  {
    id: true,
  },
  {
    name: true,
  },
  e.is(Hero, {
    secret_identity: true,
    villains: {
      id: true,
      name: true,
    },
  }),
  e.is(Villain, {
    nemesis: {id: true},
  })
);
```

Option 2:

```ts
e.select(Person, {
  id: true,
  name: true,
  IS_Hero: {
    secret_identity: true,
    villains: {
      id: true,
      name: true,
    },
  },
  IS_Villain: {
    nemesis: {
      id: true,
    },
  },
});
```

Downside with Option 2: not compatible with more union type filters in shapes (which aren't currently supported in EdgeQL but may be in the future), e.g.

```
SELECT Person {
  id,
  [IS Hero | Villain].sharedProperty
}
```

### Type intersection

```
SELECT Movie {
  id,
  characters[IS Hero]: {
    id, secret_identity
  }
}
```

Use subqueries:

```ts
e.select(Movie, {
  id: true,
  characters: e.select(e.is(Movie.characters, e.default.Hero), {
    id: true,
    secret_identity: true,
  }),
});
```

### Path reference

```ts
e.select(Hero.villains(), (villain) => ({
  shape: {id: true},
}));
```

### Property reference

```ts
const name = e.default.Hero.name;
e.select(name).filter(e.eq(name, "Iron Man")).orderBy(e.len(name));
```

### Ordering

```ts
e.select(Hero).orderBy(Hero.name);
e.select(Hero).orderBy(Hero.name, e.ASC);
e.select(Hero).orderBy(Hero.name, e.ASC, e.EMPTY_LAST);
```

### Multiple ordering

```ts
e.select(Hero, {
  name: true,
})
  .orderBy(Hero.name, e.DESC, e.EMPTY_FIRST)
  .orderBy(Hero.secret_identity, e.ASC, e.EMPTY_LAST);
```

### Pagination

```ts
e.select(Hero).offset(e.len(Hero.name)).limit(15);
```

## INSERT

```ts
const Movie = e.default.Movie;
const Person = e.default.Person;

e.insert(Movie, {
  title: "Spider-Man 2",
  characters: e
    .select(Person)
    .filter(e.in(Person.name, e.set("Spider-Man", "Doc-Ock"))),
});
```

### Conflicts

```ts
e.insert(Movie, {
  title: "Spider-Man 2",
  characters: e
    .select(Person)
    .filter(e.in(Person.name, e.set("Spider-Man", "Doc Ock"))),
}).unlessConflict(
  [Movie.title],
  e.update(Movie, {
    characters: e
      .select(Person)
      .filter(e.in(Person.name, e.set("Spider-Man", "Doc Ock"))),
  })
);
```

## UPDATE

```ts
e.update(Movie, {
  set: {
    title: e.str("Avengers: Endgame"),
  },
  add: {
    characters: e.set(e.select(Hero), e.select(Villain)),
  },
  remove: {
    characters: e.select(Villain).filter(e.eq(villain.name, e.str("Thanos")))
  }
})).filter(e.eq(Movie.title, e.str("Avengers 4")));
```

## DELETE

```ts
e.delete(Hero)
  .filter(e.eq(Hero.name, "Captain America"))
  .orderBy(/**/)
  .offset(/**/)
  .limit(/**/);
```

## WITH clauses

During the query rendering step, references to different clauses are tracked, and all orphan clauses are added in a WITH block. Clause identifiers (e.g. `WITH h1 := ()`) are generated internally.

```ts
const newHero = e.insert(Hero, {
  name: "Batman",
});

const newVillain = e.insert(Villain, {
  name: "Dr. Evil",
  nemesis: newHero,
});

return e.select(newVillain, {
  id: true,
  name: true,
});
```

If reference tracking isn't possible for some reason, alternative APIs:

```ts
return e
  .with(newHero, newVillain) // list "dependencies"
  .select(newVillain, {
    id: true,
    name: true,
  });
```

OR a fully self-contained version:

```ts
return e
  .with({
    newHero: e.insert(e.default.Hero, {
      name: "Batman",
    }),
  })
  .with((ctx) => ({
    villain: e.insert(e.default.Villain, {
      name: "Dr. Evil",
      nemesis: ctx.newHero,
    }),
  }))
  .query((ctx) =>
    e.select(ctx.villain, {
      id: true,
      name: true,
    })
  );
```

## FOR IN

As the `Set` class (described under "Type System") has a `cardinality` property, we're able to represent singleton cardinality inside a FOR/IN loop.

```ts
e.for(Hero, (hero) => {
  // do stuff
});
```

## Casting

All types are available at the top-level. Returns `Expression<Set<CastedType>>`. This syntax is liable to change based on the underlying representation of the type system (not finalized).

```ts
e.cast(e.Int16, e.int32(1255)); // <int16><int32>1255;
e.cast(e.UUID, e.str("ab1bcd81...")); // <int16>len(Hero.name);
```

## Functions

All operators are available as overloaded functions at the top level.

```ts
type AnyExpression = Expression<Set<any>, any>>;

class Len<Arg extends AnyExpression> extends Expression<Set<Int64, Arg["__cardinality"]>, number>{
  _expr: Arg;
}

function len<T extends Expression<Set<Bytes>, any>>(arg: T): Len<T>;
function len<T extends Expression<Set<Str>, any>>(arg: T): Len<T>;
function len<T extends Expression<Set<Array<any>>, any>>(arg: T): Len<T>;
function len(arg: any) {
  return new Len(arg) as any;
}

len(e.str("asdasdf"));
```

The overload enforces that `len` only accepts sets of `Bytes`, `Str`, or `Array` types. Also, the cardinality of the output reflects the cardinality of the input.

A class will be generated for each custom function in the schema.

## Operators

Operators are implements as top-level overloaded functions using the same approach used for functions.
